We start with importing the libraries and defining the variables. For data reading, we start with the accelerometer and begin transmission with the 0x3B register. We request for 6 registers (for X, Y and Z axis). The first two bytes read by the first two registers are for X axis, then Y and then Z. We use shift and OR operation for doing this. After we are done with all the readings, we end the transmission. Now, for actually calculating the force, we divide the obtained data from the accelerometer sensitivity given in the datasheet (keeping in mind that we chose the value to be +/- 2g). Next, using the above value, we calculate the accelerometer angle. We do the same thing for gyroscope as well. We request 6 registers and in the same way as above store the values for X, Y and Z axis. Then divide it by gyroscope sensitivity to find the angle. Next, we apply complementary filter to filter our data. Now, we calculate the error for our PID. Firstly, we find for proportional component and itâ€™s simply the error obtained above with the gain value. Then we set a condition that whenever our error is within the range of +/- 2 degrees, we will let the integral component work (to avoid integral winding). Finally, writing the code for derivative controller, we sum all the three to find the final PID value. Now, we give it a cap of 1000 to 2000. Finally, we print all the desired results. 
# ADR-TaskPhase
